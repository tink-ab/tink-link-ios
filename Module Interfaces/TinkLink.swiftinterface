// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.1 (swiftlang-1200.0.41 clang-1200.0.32.8)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name TinkLink
import Foundation
import Security
import Swift
@_exported import TinkCore
import UIKit
extension Account {
  public struct URI : Swift.Equatable, Swift.ExpressibleByStringLiteral {
    public let value: Swift.String
    public init(_ value: Swift.String)
    public init(stringLiteral value: Swift.String)
    public static func == (a: TinkCore.Account.URI, b: TinkCore.Account.URI) -> Swift.Bool
    public typealias StringLiteralType = Swift.String
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
  }
}
extension Account.URI {
  public init?(kind: TinkCore.AccountNumberKind, accountNumber: Swift.String)
}
extension Account.URI {
  public init(account: TinkCore.Account)
}
@_hasMissingDesignatedInitializers final public class AddBeneficiaryTask : TinkCore.Cancellable {
  public enum Status {
    case requestSent
    case authenticating(Swift.String?)
    case updating
  }
  public typealias Error = TinkLink.TinkLinkError
  final public let shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool
  @objc deinit
}
extension AddBeneficiaryTask {
  final public func cancel()
}
@_hasMissingDesignatedInitializers final public class AddCredentialsTask : Swift.Identifiable, TinkCore.Cancellable {
  public enum Status {
    case created(TinkCore.Credentials.ID)
    case authenticating(Swift.String?)
    case updating
  }
  public typealias Error = TinkLink.TinkLinkError
  final public var credentials: TinkCore.Credentials? {
    get
  }
  public struct CompletionPredicate {
    public struct SuccessPredicate : Swift.Equatable, Swift.CustomStringConvertible {
      public var description: Swift.String {
        get
      }
      public static let updating: TinkLink.AddCredentialsTask.CompletionPredicate.SuccessPredicate
      public static let updated: TinkLink.AddCredentialsTask.CompletionPredicate.SuccessPredicate
      public static func == (a: TinkLink.AddCredentialsTask.CompletionPredicate.SuccessPredicate, b: TinkLink.AddCredentialsTask.CompletionPredicate.SuccessPredicate) -> Swift.Bool
    }
    public let successPredicate: TinkLink.AddCredentialsTask.CompletionPredicate.SuccessPredicate
    public let shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool
    public init(successPredicate: TinkLink.AddCredentialsTask.CompletionPredicate.SuccessPredicate, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool)
  }
  final public let completionPredicate: TinkLink.AddCredentialsTask.CompletionPredicate
  final public func cancel()
  @objc deinit
  public typealias ID = Swift.ObjectIdentifier
}
public enum AuthenticationTask {
  case awaitingSupplementalInformation(TinkLink.SupplementInformationTask)
  case awaitingThirdPartyAppAuthentication(TinkLink.ThirdPartyAppAuthenticationTask)
}
public typealias AuthenticationTaskHandler = (TinkLink.AuthenticationTask) -> Swift.Void
final public class AuthorizationContext {
  public init(tink: TinkCore.Tink = .shared)
  @discardableResult
  final public func _authorize(scopes: [TinkCore.Scope], completion: @escaping (Swift.Result<TinkCore.AuthorizationCode, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @discardableResult
  final public func fetchClientDescription(completion: @escaping (Swift.Result<TinkCore.ClientDescription, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @objc deinit
}
public struct BeneficiaryAccount {
  public let accountNumberKind: TinkCore.AccountNumberKind
  public let accountNumber: Swift.String
  public let name: Swift.String?
  public init(accountNumberKind: TinkCore.AccountNumberKind, accountNumber: Swift.String, name: Swift.String? = nil)
}
final public class ConsentContext {
  public init(tink: TinkCore.Tink = .shared)
  @discardableResult
  final public func fetchScopeDescriptions(scopes: [TinkCore.Scope], completion: @escaping (Swift.Result<[TinkCore.ScopeDescription], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  final public func termsAndConditions(for locale: Foundation.Locale = .current) -> Foundation.URL
  final public func privacyPolicy(for locale: Foundation.Locale = .current) -> Foundation.URL
  @objc deinit
}
extension CredentialsContext {
  @available(*, deprecated, renamed: "fetchCredentials(withID:completion:)")
  final public func fetchCredentials(with id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @available(*, deprecated, message: "use add(forProviderWithName:fields:refreshableItems:completionPredicate:authenticationHandler:progressHandler:completion:) instead")
  final public func add(forProviderWithName providerName: TinkCore.Provider.Name, form: TinkLink.Form, refreshableItems: TinkCore.RefreshableItems = .all, completionPredicate: TinkLink.AddCredentialsTask.CompletionPredicate = .init(successPredicate: .updated, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: true), authenticationHandler: @escaping (TinkLink.AuthenticationTask) -> Swift.Void, progressHandler: @escaping (TinkLink.AddCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkLink.AddCredentialsTask
  @available(*, unavailable, renamed: "add(for:form:refreshableItems:completionPredicate:authenticationHandler:completion:)")
  final public func add(for provider: TinkCore.Provider, form: TinkLink.Form, refreshableItems: TinkCore.RefreshableItems = .all, completionPredicate: TinkLink.AddCredentialsTask.CompletionPredicate = .init(successPredicate: .updated, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: true), progressHandler: @escaping (TinkLink.AddCredentialsTask.Status) -> Swift.Void, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkLink.AddCredentialsTask
  @available(*, unavailable, renamed: "refresh(_:authenticate:refreshableItems:shouldFailOnThirdPartyAppAuthenticationDownloadRequired:authenticationHandler:completion:)")
  final public func refresh(_ credentials: TinkCore.Credentials, authenticate: Swift.Bool = false, refreshableItems: TinkCore.RefreshableItems = .all, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, progressHandler: @escaping (TinkLink.RefreshCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkLink.RefreshCredentialsTask
  @available(*, unavailable, renamed: "update(_:form:shouldFailOnThirdPartyAppAuthenticationDownloadRequired:authenticationHandler:completion:)")
  final public func update(_ credentials: TinkCore.Credentials, form: TinkLink.Form? = nil, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, progressHandler: @escaping (TinkLink.UpdateCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkLink.UpdateCredentialsTask
  @available(*, unavailable, renamed: "authenticate(_:shouldFailOnThirdPartyAppAuthenticationDownloadRequired:authenticationHandler:completion:)")
  final public func authenticate(_ credentials: TinkCore.Credentials, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, progressHandler: @escaping (TinkLink.AuthenticateCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkLink.AuthenticateCredentialsTask
}
@_hasMissingDesignatedInitializers final public class CredentialsContext {
  convenience public init(tink: TinkCore.Tink = .shared)
  @objc deinit
  @discardableResult
  final public func add(forProviderWithName providerName: TinkCore.Provider.Name, fields: [Swift.String : Swift.String], refreshableItems: TinkCore.RefreshableItems = .all, completionPredicate: TinkLink.AddCredentialsTask.CompletionPredicate = .init(successPredicate: .updated, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: true), authenticationHandler: @escaping (TinkLink.AuthenticationTask) -> Swift.Void, progressHandler: @escaping (TinkLink.AddCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable
  @discardableResult
  final public func add(for provider: TinkCore.Provider, form: TinkLink.Form, refreshableItems: TinkCore.RefreshableItems = .all, completionPredicate: TinkLink.AddCredentialsTask.CompletionPredicate = .init(successPredicate: .updated, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: true), authenticationHandler: @escaping (TinkLink.AuthenticationTask) -> Swift.Void, progressHandler: @escaping (TinkLink.AddCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable
  @discardableResult
  final public func fetchCredentialsList(completion: @escaping (Swift.Result<[TinkCore.Credentials], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @discardableResult
  final public func fetchCredentials(withID id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @discardableResult
  final public func refresh(_ credentials: TinkCore.Credentials, authenticate: Swift.Bool = false, refreshableItems: TinkCore.RefreshableItems = .all, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, authenticationHandler: @escaping TinkLink.AuthenticationTaskHandler, progressHandler: @escaping (TinkLink.RefreshCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable
  @discardableResult
  final public func update(_ credentials: TinkCore.Credentials, form: TinkLink.Form? = nil, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, authenticationHandler: @escaping TinkLink.AuthenticationTaskHandler, progressHandler: @escaping (TinkLink.UpdateCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable
  @discardableResult
  final public func delete(_ credentials: TinkCore.Credentials, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @discardableResult
  final public func authenticate(_ credentials: TinkCore.Credentials, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, authenticationHandler: @escaping TinkLink.AuthenticationTaskHandler, progressHandler: @escaping (TinkLink.AuthenticateCredentialsTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable
}
extension DispatchWorkItem : TinkCore.Cancellable {
}
public struct Form {
  public struct Fields : Swift.MutableCollection, Swift.RandomAccessCollection {
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(position: Swift.Int) -> TinkLink.Form.Field {
      get
      set
    }
    public func index(after i: Swift.Int) -> Swift.Int
    public subscript(name fieldName: Swift.String) -> TinkLink.Form.Field? {
      get
      set
    }
    public typealias Element = TinkLink.Form.Field
    public typealias Index = Swift.Int
    public typealias SubSequence = Swift.Slice<TinkLink.Form.Fields>
    public typealias Indices = Swift.Range<TinkLink.Form.Fields.Index>
    public typealias Iterator = Swift.IndexingIterator<TinkLink.Form.Fields>
  }
  public var fields: TinkLink.Form.Fields
  public var areFieldsValid: Swift.Bool {
    get
  }
  public func validateFields() throws
  public struct Field {
    public var text: Swift.String
    public let name: Swift.String
    public let validationRules: TinkLink.Form.Field.ValidationRules
    public var attributes: TinkLink.Form.Field.Attributes {
      get
    }
    public struct ValidationRules {
      public let isOptional: Swift.Bool
      public let maxLength: Swift.Int?
      public let minLength: Swift.Int?
    }
    public struct Attributes {
      public struct InputType : Swift.Equatable, Swift.CustomStringConvertible {
        public var description: Swift.String {
          get
        }
        public static let `default`: TinkLink.Form.Field.Attributes.InputType
        public static let numeric: TinkLink.Form.Field.Attributes.InputType
        public static func == (a: TinkLink.Form.Field.Attributes.InputType, b: TinkLink.Form.Field.Attributes.InputType) -> Swift.Bool
      }
      public let description: Swift.String
      public let placeholder: Swift.String?
      public let helpText: Swift.String?
      public let isSecureTextEntry: Swift.Bool
      public let inputType: TinkLink.Form.Field.Attributes.InputType
      public var isEditable: Swift.Bool {
        get
      }
    }
    public struct ValidationError : Swift.Error, Swift.CustomStringConvertible {
      public struct Code : Swift.Hashable {
        public static let invalid: TinkLink.Form.Field.ValidationError.Code
        public static let maxLengthLimit: TinkLink.Form.Field.ValidationError.Code
        public static let minLengthLimit: TinkLink.Form.Field.ValidationError.Code
        public static let requiredFieldEmptyValue: TinkLink.Form.Field.ValidationError.Code
        public static func ~= (lhs: TinkLink.Form.Field.ValidationError.Code, rhs: Swift.Error) -> Swift.Bool
        public var hashValue: Swift.Int {
          get
        }
        public func hash(into hasher: inout Swift.Hasher)
        public static func == (a: TinkLink.Form.Field.ValidationError.Code, b: TinkLink.Form.Field.ValidationError.Code) -> Swift.Bool
      }
      public let code: TinkLink.Form.Field.ValidationError.Code
      public var description: Swift.String {
        get
      }
      public static let invalid: TinkLink.Form.Field.ValidationError.Code
      public static let maxLengthLimit: TinkLink.Form.Field.ValidationError.Code
      public static let minLengthLimit: TinkLink.Form.Field.ValidationError.Code
      public static let requiredFieldEmptyValue: TinkLink.Form.Field.ValidationError.Code
      public var fieldName: Swift.String
      public var reason: Swift.String?
      public var minLength: Swift.Int?
      public var maxLength: Swift.Int?
    }
    public var isValid: Swift.Bool {
      get
    }
    public func validate() throws
  }
  public struct ValidationError : Swift.Error {
    public var errors: [TinkLink.Form.Field.ValidationError]
    public subscript(fieldName fieldName: Swift.String) -> TinkLink.Form.Field.ValidationError? {
      get
    }
  }
}
extension Form {
  public init(provider: TinkCore.Provider)
  @available(*, deprecated, message: "Use init(supplementInformationTask:) instead.")
  public init(credentials: TinkCore.Credentials)
  public init(updatingCredentials: TinkCore.Credentials, provider: TinkCore.Provider)
  public init(supplementInformationTask: TinkLink.SupplementInformationTask)
}
@_hasMissingDesignatedInitializers final public class InitiateTransferTask : TinkCore.Cancellable {
  public enum Status {
    case created(TinkCore.Transfer.ID)
    case authenticating(Swift.String?)
    case updating
    case executing(status: Swift.String)
  }
  public typealias AuthenticationTask = TinkLink.AuthenticationTask
  public typealias Error = TinkLink.TinkLinkError
  public struct Receipt {
    public let id: TinkCore.Transfer.ID
    public let message: Swift.String?
  }
  final public let shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool
  final public func cancel()
  @objc deinit
}
extension ProviderContext {
  @available(*, deprecated, renamed: "Filter")
  public typealias Attributes = TinkLink.ProviderContext.Filter
  @available(*, deprecated, renamed: "fetchProviders(filter:completion:)")
  final public func fetchProviders(attributes: TinkLink.ProviderContext.Filter, completion: @escaping (Swift.Result<[TinkCore.Provider], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
@_hasMissingDesignatedInitializers final public class ProviderContext {
  public struct Filter : Swift.Hashable {
    public let capabilities: TinkCore.Provider.Capabilities
    public let kinds: Swift.Set<TinkCore.Provider.Kind>
    public let accessTypes: Swift.Set<TinkCore.Provider.AccessType>
    public init(capabilities: TinkCore.Provider.Capabilities, kinds: Swift.Set<TinkCore.Provider.Kind>, accessTypes: Swift.Set<TinkCore.Provider.AccessType>)
    public static let `default`: TinkLink.ProviderContext.Filter
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TinkLink.ProviderContext.Filter, b: TinkLink.ProviderContext.Filter) -> Swift.Bool
  }
  convenience public init(tink: TinkCore.Tink = .shared)
  @discardableResult
  final public func fetchProviders(filter: TinkLink.ProviderContext.Filter = .default, completion: @escaping (Swift.Result<[TinkCore.Provider], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @discardableResult
  final public func fetchProvider(with name: TinkCore.Provider.Name, completion: @escaping (Swift.Result<TinkCore.Provider, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @objc deinit
}
public struct ProviderTree {
  public let financialInstitutionGroups: [TinkLink.ProviderTree.FinancialInstitutionGroupNode]
  public init(providers: [TinkCore.Provider])
  public func makeFinancialInstitutions() -> [TinkLink.ProviderTree.FinancialInstitutionNode]
  public struct CredentialsKindNode : Swift.Comparable {
    public static func < (lhs: TinkLink.ProviderTree.CredentialsKindNode, rhs: TinkLink.ProviderTree.CredentialsKindNode) -> Swift.Bool
    public static func == (lhs: TinkLink.ProviderTree.CredentialsKindNode, rhs: TinkLink.ProviderTree.CredentialsKindNode) -> Swift.Bool
    public typealias ID = TinkCore.Identifier<TinkLink.ProviderTree.CredentialsKindNode>
    public var id: TinkLink.ProviderTree.CredentialsKindNode.ID {
      get
    }
    public let provider: TinkCore.Provider
    public var credentialsKind: TinkCore.Credentials.Kind {
      get
    }
    public var displayDescription: Swift.String {
      get
    }
    public var imageURL: Foundation.URL? {
      get
    }
  }
  public enum AccessTypeNode : Swift.Comparable {
    public static func < (lhs: TinkLink.ProviderTree.AccessTypeNode, rhs: TinkLink.ProviderTree.AccessTypeNode) -> Swift.Bool
    public static func == (lhs: TinkLink.ProviderTree.AccessTypeNode, rhs: TinkLink.ProviderTree.AccessTypeNode) -> Swift.Bool
    public typealias ID = TinkCore.Identifier<TinkLink.ProviderTree.AccessTypeNode>
    case provider(TinkCore.Provider)
    case credentialsKinds([TinkLink.ProviderTree.CredentialsKindNode])
    public var id: TinkLink.ProviderTree.AccessTypeNode.ID {
      get
    }
    public var providers: [TinkCore.Provider] {
      get
    }
    public var accessType: TinkCore.Provider.AccessType {
      get
    }
    public var imageURL: Foundation.URL? {
      get
    }
  }
  public enum AuthenticationUserTypeNode : Swift.Comparable {
    public static func < (lhs: TinkLink.ProviderTree.AuthenticationUserTypeNode, rhs: TinkLink.ProviderTree.AuthenticationUserTypeNode) -> Swift.Bool
    public static func == (lhs: TinkLink.ProviderTree.AuthenticationUserTypeNode, rhs: TinkLink.ProviderTree.AuthenticationUserTypeNode) -> Swift.Bool
    public typealias ID = TinkCore.Identifier<TinkLink.ProviderTree.AuthenticationUserTypeNode>
    case provider(TinkCore.Provider)
    case credentialsKinds([TinkLink.ProviderTree.CredentialsKindNode])
    case accessTypes([TinkLink.ProviderTree.AccessTypeNode])
    public var providers: [TinkCore.Provider] {
      get
    }
    public var id: TinkLink.ProviderTree.AuthenticationUserTypeNode.ID {
      get
    }
    public var authenticationUserType: TinkCore.Provider.AuthenticationUserType {
      get
    }
    public var imageURL: Foundation.URL? {
      get
    }
    public var financialInstitution: TinkCore.Provider.FinancialInstitution {
      get
    }
  }
  public enum FinancialInstitutionNode : Swift.Comparable {
    public static func < (lhs: TinkLink.ProviderTree.FinancialInstitutionNode, rhs: TinkLink.ProviderTree.FinancialInstitutionNode) -> Swift.Bool
    public static func == (lhs: TinkLink.ProviderTree.FinancialInstitutionNode, rhs: TinkLink.ProviderTree.FinancialInstitutionNode) -> Swift.Bool
    public typealias ID = TinkCore.Identifier<TinkLink.ProviderTree.FinancialInstitutionNode>
    case provider(TinkCore.Provider)
    case credentialsKinds([TinkLink.ProviderTree.CredentialsKindNode])
    case accessTypes([TinkLink.ProviderTree.AccessTypeNode])
    case authenticationUserTypes([TinkLink.ProviderTree.AuthenticationUserTypeNode])
    public var id: TinkLink.ProviderTree.FinancialInstitutionNode.ID {
      get
    }
    public var providers: [TinkCore.Provider] {
      get
    }
    public var financialInstitution: TinkCore.Provider.FinancialInstitution {
      get
    }
    public var imageURL: Foundation.URL? {
      get
    }
  }
  public enum FinancialInstitutionGroupNode : Swift.Identifiable {
    public typealias ID = TinkCore.Identifier<TinkLink.ProviderTree.FinancialInstitutionGroupNode>
    case provider(TinkCore.Provider)
    case credentialsKinds([TinkLink.ProviderTree.CredentialsKindNode])
    case accessTypes([TinkLink.ProviderTree.AccessTypeNode])
    case financialInstitutions([TinkLink.ProviderTree.FinancialInstitutionNode])
    case authenticationUserTypes([TinkLink.ProviderTree.AuthenticationUserTypeNode])
    public var id: TinkLink.ProviderTree.FinancialInstitutionGroupNode.ID {
      get
    }
    public var providers: [TinkCore.Provider] {
      get
    }
    public var displayName: Swift.String {
      get
    }
    public var imageURL: Foundation.URL? {
      get
    }
  }
}
extension Array where Element == TinkLink.ProviderTree.FinancialInstitutionGroupNode {
  public func makeFinancialInstitutions() -> [TinkLink.ProviderTree.FinancialInstitutionNode]
}
public typealias AuthenticateCredentialsTask = TinkLink.RefreshCredentialsTask
public typealias UpdateCredentialsTask = TinkLink.RefreshCredentialsTask
@_hasMissingDesignatedInitializers final public class RefreshCredentialsTask : Swift.Identifiable, TinkCore.Cancellable {
  public enum Status {
    case authenticating(Swift.String?)
    case updating
  }
  public typealias Error = TinkLink.TinkLinkError
  final public let shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool
  final public var credentials: TinkCore.Credentials {
    get
  }
  final public func cancel()
  @objc deinit
  public typealias ID = Swift.ObjectIdentifier
}
@_hasMissingDesignatedInitializers final public class SupplementInformationTask : Swift.Identifiable {
  public struct Error : Swift.Error, Swift.CustomStringConvertible {
    public struct Code : Swift.Hashable {
      public static let cancelled: TinkLink.SupplementInformationTask.Error.Code
      public static func ~= (lhs: TinkLink.SupplementInformationTask.Error.Code, rhs: Swift.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: TinkLink.SupplementInformationTask.Error.Code, b: TinkLink.SupplementInformationTask.Error.Code) -> Swift.Bool
    }
    public var code: TinkLink.SupplementInformationTask.Error.Code
    public var description: Swift.String {
      get
    }
    public static let cancelled: TinkLink.SupplementInformationTask.Error.Code
  }
  final public let credentials: TinkCore.Credentials
  final public func submit(_ form: TinkLink.Form)
  final public func cancel()
  @objc deinit
  public typealias ID = Swift.ObjectIdentifier
}
@_hasMissingDesignatedInitializers public class ThirdPartyAppAuthenticationTask : Swift.Identifiable {
  public struct Error : Swift.Error, Swift.CustomStringConvertible {
    public struct Code : Swift.Hashable {
      public static let deeplinkURLNotFound: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
      public static let downloadRequired: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
      public static let doesNotSupportAuthenticatingOnAnotherDevice: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
      public static let decodingQRCodeImageFailed: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
      public static let cancelled: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
      public static func ~= (lhs: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code, rhs: Swift.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code, b: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code) -> Swift.Bool
    }
    public let code: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
    public var description: Swift.String {
      get
    }
    public static let deeplinkURLNotFound: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
    public static let downloadRequired: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
    public static let doesNotSupportAuthenticatingOnAnotherDevice: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
    public static let decodingQRCodeImageFailed: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
    public static let cancelled: TinkLink.ThirdPartyAppAuthenticationTask.Error.Code
    public var downloadTitle: Swift.String?
    public var downloadMessage: Swift.String?
    public var appStoreURL: Foundation.URL?
  }
  public enum Status {
    case qrImage(UIKit.UIImage)
    case awaitAuthenticationOnAnotherDevice
  }
  public var thirdPartyAppAuthentication: TinkCore.Credentials.ThirdPartyAppAuthentication {
    get
  }
  public var shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool {
    get
  }
  public func handle()
  public func handle(statusHandler: @escaping (TinkLink.ThirdPartyAppAuthenticationTask.Status) -> Swift.Void)
  public func cancel()
  @objc deinit
  public typealias ID = Swift.ObjectIdentifier
}
extension Tink {
  @available(iOS 9.0, *)
  @available(*, deprecated, message: "Use Tink.open(_:completion:) instead.")
  public func open(_ url: Foundation.URL, completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)? = nil) -> Swift.Bool
  @available(iOS 9.0, *)
  public static func open(_ url: Foundation.URL, completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)? = nil) -> Swift.Bool
}
public struct TinkLinkConfiguration : TinkCore.Configuration {
  public var clientID: Swift.String
  public var appURI: Foundation.URL?
  public var environment: TinkCore.Tink.Environment
  public var certificateURL: Foundation.URL?
  public init(clientID: Swift.String, appURI: Foundation.URL, environment: TinkCore.Tink.Environment = .production, certificateURL: Foundation.URL? = nil)
}
public struct TinkLinkError : Swift.Error, Swift.CustomStringConvertible {
  public struct Code : Swift.Hashable {
    public static let credentialsAuthenticationFailed: TinkLink.TinkLinkError.Code
    public static let temporaryCredentialsFailure: TinkLink.TinkLinkError.Code
    public static let permanentCredentialsFailure: TinkLink.TinkLinkError.Code
    public static let credentialsAlreadyExists: TinkLink.TinkLinkError.Code
    public static let credentialsDeleted: TinkLink.TinkLinkError.Code
    public static let credentialsSessionExpired: TinkLink.TinkLinkError.Code
    public static let cancelled: TinkLink.TinkLinkError.Code
    public static let transferFailed: TinkLink.TinkLinkError.Code
    public static let notFound: TinkLink.TinkLinkError.Code
    public static let invalidArguments: TinkLink.TinkLinkError.Code
    public static let missingRequiredScope: TinkLink.TinkLinkError.Code
    public static let notAuthenticated: TinkLink.TinkLinkError.Code
    public static let tooManyRequests: TinkLink.TinkLinkError.Code
    public static let unavailableForLegalReasons: TinkLink.TinkLinkError.Code
    public static let internalError: TinkLink.TinkLinkError.Code
    public static let notConnectedToInternet: TinkLink.TinkLinkError.Code
    public static let networkFailure: TinkLink.TinkLinkError.Code
    public static func ~= (lhs: TinkLink.TinkLinkError.Code, rhs: Swift.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TinkLink.TinkLinkError.Code, b: TinkLink.TinkLinkError.Code) -> Swift.Bool
  }
  public let code: TinkLink.TinkLinkError.Code
  public let message: Swift.String?
  public var description: Swift.String {
    get
  }
  public static let credentialsAuthenticationFailed: TinkLink.TinkLinkError.Code
  public static let temporaryCredentialsFailure: TinkLink.TinkLinkError.Code
  public static let permanentCredentialsFailure: TinkLink.TinkLinkError.Code
  public static let credentialsAlreadyExists: TinkLink.TinkLinkError.Code
  public static let credentialsDeleted: TinkLink.TinkLinkError.Code
  public static let credentialsSessionExpired: TinkLink.TinkLinkError.Code
  public static let cancelled: TinkLink.TinkLinkError.Code
  public static let transferFailed: TinkLink.TinkLinkError.Code
  public static let notFound: TinkLink.TinkLinkError.Code
  public static let invalidArguments: TinkLink.TinkLinkError.Code
  public static let missingRequiredScope: TinkLink.TinkLinkError.Code
  public static let notAuthenticated: TinkLink.TinkLinkError.Code
  public static let tooManyRequests: TinkLink.TinkLinkError.Code
  public static let unavailableForLegalReasons: TinkLink.TinkLinkError.Code
  public static let internalError: TinkLink.TinkLinkError.Code
  public static let notConnectedToInternet: TinkLink.TinkLinkError.Code
  public static let networkFailure: TinkLink.TinkLinkError.Code
}
final public class TinkLinkSessionManager : TinkCore.SessionManager {
  public init(tink: TinkCore.Tink = .shared)
  @objc deinit
}
extension Tink {
  public var authorizationContext: TinkLink.AuthorizationContext {
    get
  }
  public var consentContext: TinkLink.ConsentContext {
    get
  }
  public var credentialsContext: TinkLink.CredentialsContext {
    get
  }
  public var providerContext: TinkLink.ProviderContext {
    get
  }
  public var transferContext: TinkLink.TransferContext {
    get
  }
}
extension Tink {
  public func _beginUITask()
  public func _endUITask()
}
public protocol TransferAccountIdentifiable {
  var transferAccountID: Swift.String { get }
}
extension Account : TinkLink.TransferAccountIdentifiable {
  public var transferAccountID: Swift.String {
    get
  }
}
extension Account.URI : TinkLink.TransferAccountIdentifiable {
  public var transferAccountID: Swift.String {
    get
  }
}
extension Beneficiary : TinkLink.TransferAccountIdentifiable {
  public var transferAccountID: Swift.String {
    get
  }
}
extension BeneficiaryAccount : TinkLink.TransferAccountIdentifiable {
  public var transferAccountID: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TransferContext {
  convenience public init(tink: TinkCore.Tink = .shared)
  @discardableResult
  final public func initiateTransfer(from account: TinkLink.TransferAccountIdentifiable, to beneficiary: TinkLink.TransferAccountIdentifiable, amount: TinkCore.CurrencyDenominatedAmount, message: TinkLink.InitiateTransferTask.Message, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, authentication: @escaping (TinkLink.AuthenticationTask) -> Swift.Void, progress: @escaping (TinkLink.InitiateTransferTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<TinkLink.InitiateTransferTask.Receipt, Swift.Error>) -> Swift.Void) -> TinkLink.InitiateTransferTask
  @discardableResult
  final public func fetchAccounts(completion: @escaping (Swift.Result<[TinkCore.Account], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @discardableResult
  final public func fetchBeneficiaries(for account: TinkCore.Account, completion: @escaping (Swift.Result<[TinkCore.Beneficiary], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @discardableResult
  final public func fetchBeneficiaries(completion: @escaping (Swift.Result<[TinkCore.Beneficiary], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  @discardableResult
  final public func addBeneficiary(account beneficiaryAccount: TinkLink.BeneficiaryAccount, name: Swift.String, to ownerAccount: TinkCore.Account, credentials: TinkCore.Credentials? = nil, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, authentication: @escaping (TinkLink.AuthenticationTask) -> Swift.Void, progress: @escaping (TinkLink.AddBeneficiaryTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkLink.AddBeneficiaryTask
  @discardableResult
  final public func addBeneficiary(account beneficiaryAccount: TinkLink.BeneficiaryAccount, name: Swift.String, toAccountWithID ownerAccountID: TinkCore.Account.ID, onCredentialsWithID credentialsID: TinkCore.Credentials.ID, shouldFailOnThirdPartyAppAuthenticationDownloadRequired: Swift.Bool = true, authentication: @escaping (TinkLink.AuthenticationTask) -> Swift.Void, progress: @escaping (TinkLink.AddBeneficiaryTask.Status) -> Swift.Void = { _ in }, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkLink.AddBeneficiaryTask
  @objc deinit
}
extension InitiateTransferTask {
  public struct Message {
    public var source: Swift.String?
    public var destination: Swift.String
    public init(source: Swift.String? = nil, destination: Swift.String)
  }
}
